@QUANTUMINPUT_PYTHON2_SHEBANG@

"""
/******************************************************************************

  This source file is part of the Avogadro project.

  Copyright 2013 Kitware, Inc.

  This source code is released under the New BSD License, (the "License").

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

******************************************************************************/
"""

import argparse
import json
import sys

# Some globals:
targetName = 'LAMMPS'
extension = 'in'
debug = False

def getOptions():
  userOptions = {}

  userOptions['Title'] = {}
  userOptions['Title']['type'] = 'string'
  userOptions['Title']['default'] = '%s input generated by Avogadro.'%targetName

  userOptions['Force Field'] = {}
  userOptions['Force Field']['type'] = 'stringList'
  userOptions['Force Field']['default'] = 0
  userOptions['Force Field']['values'] = \
    ['CHARMM', 'AMBER']

  userOptions['Minimization Algorithm'] = {}
  userOptions['Minimization Algorithm']['type'] = 'stringList'
  userOptions['Minimization Algorithm']['default'] = 1
  userOptions['Minimization Algorithm']['values'] = \
    ['Steepest Descent', 'Conjugate Gradient', 'Quasi-Newton']

  # TODO make this a float
  userOptions['Box Padding'] = {}
  userOptions['Box Padding']['type'] = 'integer'
  userOptions['Box Padding']['default'] = 10
  userOptions['Box Padding']['minimum'] = 0
  userOptions['Box Padding']['maximum'] = 100
  userOptions['Box Padding']['suffix'] = ' Angstrom'

  opts = {'userOptions' : userOptions}
  opts['inputMoleculeFormat'] = 'cjson'

  return opts

def generateGeometryFile(cjson, opts, settings):
  # Extract options:
  title = opts['Title']
  padding = opts['Box Padding']

  # Precalculate some quantities:
  coords = cjson['atoms']['coords']['3d']
  atomicNums = cjson['atoms']['elements']['number']
  bondConnections = cjson['bonds']['connections']['index']
  bondOrders = cjson['bonds']['order']
  # - Number of atoms:
  numAtoms = len(atomicNums)
  # - Number of bonds
  numBonds = len(cjson['bonds']['order'])
  # - molecule bbox:

  xmin = ymin = zmin = max(coords)
  xmax = ymax = zmax = min(coords)
  for atom in range(numAtoms):
    x = coords[3*atom + 0]
    y = coords[3*atom + 1]
    z = coords[3*atom + 2]
    if x < xmin: xmin = x
    if x > xmax: xmax = x
    if y < ymin: ymin = y
    if y > ymax: ymax = y
    if z < zmin: zmin = z
    if z > zmax: zmax = z

  # Create file contents
  geo = ''

  # Header
  geo += '%s\n'%title
  geo += '%d atoms\n'%numAtoms
  geo += '%d bonds\n'%numBonds
  geo += '%9.5f %9.5f xlo xhi\n'%(xmin - padding, xmax + padding)
  geo += '%9.5f %9.5f ylo yhi\n'%(ymin - padding, ymax + padding)
  geo += '%9.5f %9.5f zlo zhi\n'%(zmin - padding, zmax + padding)

  # Atoms
  geo += '\nAtoms\n'
  for atom in range(numAtoms):
    atomicNum = atomicNums[atom]
    x = coords[3*atom + 0]
    y = coords[3*atom + 1]
    z = coords[3*atom + 2]
    geo += '%d %d %9.5f %9.5f %9.5f\n'%(atom, atomicNum, x, y, z)

  # Bonds
  geo += '\nBonds\n'
  for bond in range(numBonds):
    order = bondOrders[bond]
    start = bondConnections[2*bond + 0]
    end   = bondConnections[2*bond + 1]
    geo += '%d %d %d %d\n'%(bond, order, start, end)

  return geo

def getForceFieldStyle(ff):
  result = ''
  if ff in ['CHARMM', 'AMBER']:
    result += 'bond_style harmonic\n'
    result += 'angle_style charmm\n'
    result += 'dihedral_style charmm\n'
    result += 'pair_style lj/charmm/coul/charmm\n'
    result += 'special_bonds %s\n'%ff.lower()
  else:
    raise Exception("Unrecognized force field: %s"%ff)
  return result

def generateInputFile(cjson, opts, settings):
  # Extract options:
  title = opts['Title']
  minAlg = opts['Minimization Algorithm']
  forceField = opts['Force Field']

  # Calculate some quantities
  atomicNums = cjson['atoms']['elements']['number']
  numAtoms = len(atomicNums)

  # Setup some strings
  atom_modify = 'map '
  if numAtoms < 10000:
    atom_modify += 'array'
  else:
    atom_modify += 'hash'

  min_style = ''
  if minAlg == 'Steepest Descent':
    min_style = 'sd'
  elif minAlg == 'Conjugate Gradient':
    min_style = 'cg'
  elif minAlg == 'Quasi-Newton':
    min_style = 'hftn'
  else:
    raise Exception("Unrecognized minimization algorithm: %s"%minAlg)

  ff_style = getForceFieldStyle(forceField)

  ## Create input file
  output = ''

  output += '# %s\n'%title

  # TODO remove this at some point.
  output += '# WARNING: This generator is still under development. The files\n'
  output += '# produced will require manual editing before they can run.\n'

  output += '\n### Initialize Simulation ###\n'
  output += 'clear\n'
  output += 'units real\n'
  output += 'dimension 3\n'
  output += 'boundary s s s # (p)eriodic (f)ixed (s)hrink\n'
  output += 'atom_style atomic\n'
  output += ff_style
  output += 'atom_modify %s\n'%atom_modify

  output += '\n#\n# Create Atoms\n#\n'
  output += 'read_data job.geometry\n'

  output += '\n#\n# Define Interactions\n#\n'
  output += 'TODO\n'

  output += '\n#\n# Run Simulation\n#\n'
  output += 'reset_timestep 0\n'
  output += 'thermo 10 # Print thermo data every N steps\n'
  output += 'thermo_style one # Print thermo data every N steps\n'
  output += 'min_style %s\n'%min_style
  output += 'minimize 1e-6 1e-6 2000 20000\n'

  return output

def generateInput():
  # Read options from stdin
  stdinStr = sys.stdin.read()

  # Parse the JSON strings
  opts = json.loads(stdinStr)

  # Generate the input file
  inp = generateInputFile(opts['cjson'], opts['options'], opts['settings'])
  geo = generateGeometryFile(opts['cjson'], opts['options'], opts['settings'])

  # Prepare the result
  result = {}
  # Input file text -- will appear in the same order in the GUI as they are
  # listed in the array:
  files = []
  files.append({'filename': 'job.%s'%extension, 'contents': inp})
  files.append({'filename': 'job.geometry', 'contents': geo})

  if debug:
    files.append({'filename': 'debug_info', 'contents': stdinStr})
  result['files'] = files
  # Specify the main input file. This will be used by MoleQueue to determine
  # the value of the $$inputFileName$$ and $$inputFileBaseName$$ keywords.
  result['mainFile'] = 'job.%s'%extension
  return result

if __name__ == "__main__":
  parser = argparse.ArgumentParser('Generate a %s input file.'%targetName)
  parser.add_argument('--debug', action='store_true')
  parser.add_argument('--print-options', action='store_true')
  parser.add_argument('--generate-input', action='store_true')
  parser.add_argument('--display-name', action='store_true')
  args = vars(parser.parse_args())

  debug = args['debug']

  if args['display_name']:
    print(targetName)
  if args['print_options']:
    print(json.dumps(getOptions()))
  elif args['generate_input']:
    print(json.dumps(generateInput()))
