/******************************************************************************
  This source file is part of the Avogadro project.

  This source code is released under the New BSD License, (the "License").
******************************************************************************/

#ifndef AVOGADRO_QTPLUGINS_EDTSURFACECONCURRENT_H
#define AVOGADRO_QTPLUGINS_EDTSURFACECONCURRENT_H

#include "bitvector.h"
#include "boolcube.h"
#include "surfaces.h"
#include <avogadro/core/avogadrocore.h>
#include <avogadro/core/vector.h>
#include <QtCore/QFuture>
#include <QtCore/QFutureWatcher>
#include <QtCore/QObject>

// for the enum

namespace Avogadro {
namespace Core {
class Cube;
class Molecule;
class Atom;
}
namespace QtGui {
class Molecule;
}

namespace QtPlugins {

typedef struct dataStruct
{
  int pHeight, pWidth, pLength, boxLength;
  Vector3 pMin, pMax, pTran;
  double probeRadius;
  double scaleFactor;
  bool ignoreHydrogens; // if we want this feature, write a way of setting it
} dataStruct;           // End struct dataStruct

typedef struct subCube{
  int height, width, length;
  Core::Molecule* mol;
  Core::Cube* cube;
  BoolCube* isInSolid;
  BoolCube* isOnSurface;
  Vector3i** vdwSpheres;
  dataStruct* data;
  int* numsOfVectors;
  int numOfSurfaceVoxels;
  Vector3i* surfaceVoxels;
  int index;
} subCube;

class EDTSurface
{
public:
  // Constructor
  EDTSurfaceConcurrent();

  // Destructor
  virtual ~EDTSurfaceConcurrent();

  /*@brief Populates a cube with values generated by doing a Euclidean distance
   *transform on the molecule provided
   *@param mol A pointer to a the molecule from which the cube is to be
   *generated
   *@param surfaceType an enum class representing the type of surface (VdW, SES,
   *SAS)
   *@returns a pointer to the cube
   */

  Core::Cube* EDTCube(QtGui::Molecule* mol, Core::Cube* cube,
                      Surfaces::Type surfaceType);

  // The copying over from array to Cube can and should be done in parallel

  /*@brief Populates a cube with values generated by doing a Euclidean distance
   *transform on the molecule provided
   *@param mol A pointer to a the molecule from which the cube is to be
   *generated
   *@param surfaceType an enum class representing the type of surface (VdW, SES,
   *SAS)
   *@param probeRadius a double representing the molecular radius of the solvent
   *@returns a pointer to the cube
   */

  Core::Cube* EDTCube(QtGui::Molecule* mol, Core::Cube* cube,
                      Surfaces::Type surfaceType, double probeRadius);
  // Takes a molecule, a surface type and a probeRadius and

  /*@brief Sets a pointer to the desired molecule
   *@param mol a pointer to the molecule to be set
   */

  void setMolecule(QtGui::Molecule* mol);

  /*@brief Sets the probe radius to a desired value (default is 1.4 - water)
   *@param probeRadius The molecular radius of the solvent
   */

  void setProbeRadius(double probeRadius);

  void setCube(Core::Cube* cube);

  double getScaleFactor();

  Vector3 getPTran();

  QFutureWatcher<void> & watcher() { return m_watcher; }

  private Q_SLOTS:
    /**
     * Slot to set the cube data once Qt Concurrent is done
     */
     void calculationComplete();

  Q_SIGNALS:

private:
  /*
   *@brief Initializes the data members of the class
   *@param surfaceType
   */

  void initPara();

  /*
   *@brief Builds the solvent accessible solid by iterating over atoms in the
   *molecule and filling in the voxels for each.  Note that the VWS is the SAS
   *with probe radius equal to 0
   */

  void buildSolventAccessibleSolid();

  // try initializing the array here

  /*@brief fills in the voxels in the sphere representing the atom
   *
   */

  void fillAtom(subCube &edt);

  // try initializing the array here

  /*
   *@brief shrinks the solvent accessible solid by the probe radius to obtain
   *the solvent excluded solid
   */

  void buildSolventExcludedSolid();
    //We can do this concurrently by atoms

  void fillAtomWaals(subCube &edt);
    //Modify this to take a subCube

  /*
   *@brief fills in the cube with values representing distances from each point
   *to the nearest point on the surface
   */

  void fastDistanceMap(subCube &edt);
  //This can be concurrent over the cube
  /*
   *@brief Determines which points in the solid are on the surface
   */

  void buildSurface();

  void buildSurfaceConcurrent(subCube &edt);

  //This can't be concurrent

  /*
   *@brief Finds the bound box for the molecule, the smallest cube that can
   *contain it
   */

  void boundBox();

  /*
   *@brief precomputes the sphere representing an atom of an element
   *points in the atom are represented as vectors stored in the array spheres
   */

  void computeSphere(unsigned char atomicNumber);

  /*
   *@brief Takes a vector and tells whether or not it's within the bounds of the
   *box
   */
  bool inBounds(Vector3i vec);

  /*
   *@brief Takes a floating point vector and returns an integer vector
   */

  Vector3i round(Vector3 vec);

  /*
   *@brief Promotes each element of an integer vector to a double
   */

  Vector3 promote(Vector3i vec);

  QtGui::Molecule* m_mol;

  Core::Cube* m_cube;

  bool*** testArray;

  BoolCube* inSolid; // bool cube representing whether each point is in the
                     // solid
  BoolCube*
    onSurface; // bool cube representing whether each point is on the surface

  // We can do things as BitVectors, too
  //  BitVector* inSolid;
  //  BitVector* onSurface;

  Vector3i*
    neighbors; // array of vectors representing the points adjacent to a point

  Vector3i** spheres; // An array of pointers to arrays of vectors representing
                      // all the points each sphere
  int* numbersOfVectors; // The number of vectors in each sphere
  bool* computed; // An array of bools that tells us if we've already computed
                  // the sphere for this element

  dataStruct* data;

  int numberOfSurfaceVoxels; // the number of voxels on the surface
  Vector3i* surfaceVoxels;   // array where we store all the voxels that are on
                           // our surface

  int numberOfInnerVoxels; // this is a debugging value

  QFuture<void> m_future;
  QFutureWatcher<void> m_watcher;
  QVector<subCube> m_edtVector;
};                         // End class EDTSurface

} // End namespace QtPlugins
} // End namespace Avogadro

#endif
