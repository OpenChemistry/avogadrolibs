/******************************************************************************
  This source file is part of the Avogadro project.

  This source code is released under the New BSD License, (the "License").
******************************************************************************/

#ifndef AVOGADRO_QTPLUGINS_EDTSURFACECONCURRENT_H
#define AVOGADRO_QTPLUGINS_EDTSURFACECONCURRENT_H

#include "surfaces.h"
#include <QtCore/QFuture>
#include <QtCore/QFutureWatcher>
#include <QtCore/QObject>
#include <avogadro/core/avogadrocore.h>
#include <avogadro/core/vector.h>

// for the enum

namespace Avogadro {
namespace Core {
class Cube;
class Molecule;
class Atom;
}
namespace QtGui {
class Molecule;
}

namespace QtPlugins {

typedef struct dataStruct
{
  int pHeight, pWidth, pLength;
  Vector3 pMin, pMax, pTran;
  double probeRadius;
  double scaleFactor, resolution;
} dataStruct; // End struct dataStruct

typedef struct subCube
{
  Core::Cube* cube;
  dataStruct* data;
  int numOfSurfaceVoxels;
  int* surfaceVoxelCount;
  Vector3i* surfaceVoxels;
  int index;
} subCube;

typedef struct atomStruct
{
  Core::Molecule* mol;
  Core::Cube* cube;
  Vector3i* vdwSphere;
  int numberOfVectors;
  int atomicNumber;
  Vector3 position;
  dataStruct* data;
  int index;
} atomStruct;

class EDTSurfaceConcurrent : public QObject
{

  Q_OBJECT
public:
  // Constructor
  EDTSurfaceConcurrent();

  // Destructor
  virtual ~EDTSurfaceConcurrent();

  /*@brief Populates a cube with values generated by doing a Euclidean distance
   *transform on the molecule provided
   *@param mol A pointer to a the molecule from which the cube is to be
   *generated
   *@param surfaceType an enum class representing the type of surface (VdW, SES,
   *SAS)
   *@returns a pointer to the cube
   */

  Core::Cube* EDTCube(QtGui::Molecule* mol, Core::Cube* cube,
                      Surfaces::Type surfaceType, double resolution);

  // The copying over from array to Cube can and should be done in parallel

  /*@brief Populates a cube with values generated by doing a Euclidean distance
   *transform on the molecule provided
   *@param mol A pointer to a the molecule from which the cube is to be
   *generated
   *@param surfaceType an enum class representing the type of surface (VdW, SES,
   *SAS)
   *@param probeRadius a double representing the molecular radius of the solvent
   *@returns a pointer to the cube
   */

  Core::Cube* EDTCube(QtGui::Molecule* mol, Core::Cube* cube,
                      Surfaces::Type surfaceType, double probeRadius,
                      double resolution);
  // Takes a molecule, a surface type and a probeRadius and

  /*@brief Sets a pointer to the desired molecule
   *@param mol a pointer to the molecule to be set
   */

  void setMolecule(QtGui::Molecule* mol);

  /*@brief Sets the probe radius to a desired value (default is 1.4 - water)
   *@param probeRadius The molecular radius of the solvent
   */

  void setProbeRadius(double probeRadius);

  void setCube(Core::Cube* cube);

  QFutureWatcher<void>& watcher() { return m_watcher; }

private Q_SLOTS:
  /**
   * Slot to set the cube data once Qt Concurrent is done
   */
  void calculationComplete();

Q_SIGNALS:

private:
  /*
   *@brief Initializes the data members of the class
   *@param surfaceType
   */

  void initPara();

  /*
   *@brief Builds the solvent accessible solid by iterating over atoms in the
   *molecule and filling in the voxels for each.  Note that the VWS is the SAS
   *with probe radius equal to 0
   */

  void buildSolventAccessibleSolid();

  // try initializing the array here

  /*@brief fills in the voxels in the sphere representing the atom
   *
   */

  static void fillAtom(atomStruct& edt);

  // try initializing the array here

  /*
   *@brief shrinks the solvent accessible solid by the probe radius to obtain
   *the solvent excluded solid
   */

  void buildSolventExcludedSolid();
  // We can do this concurrently by atoms

  static void fillAtomWaals(atomStruct& edt);
  // Modify this to take a subCube

  /*
   *@brief fills in the cube with values representing distances from each point
   *to the nearest point on the surface
   */

  void fastDistanceMap();
  // This can be concurrent over the cube
  /*
   *@brief Determines which points in the solid are on the surface
   */

  static void fastDistanceMapConcurrent(subCube& edt);

  void buildSurface();

  static void buildSurfaceConcurrent(subCube& edt);

  // This can't be concurrent

  /*
   *@brief Finds the bound box for the molecule, the smallest cube that can
   *contain it
   */

  void boundBox();

  /*
   *@brief precomputes the sphere representing an atom of an element
   *points in the atom are represented as vectors stored in the array spheres
   */

  void computeSphere(unsigned char atomicNumber);

  /*
   *@brief Takes a vector and tells whether or not it's within the bounds of the
   *box
   */
  bool inBounds(Vector3i vec);

  static bool inBounds(Vector3i vec, dataStruct* data);

  /*
   *@brief Takes a floating point vector and returns an integer vector
   */

  static Vector3i round(Vector3 vec);

  /*
   *@brief Promotes each element of an integer vector to a double
   */

  static Vector3 promote(Vector3i vec);

  QtGui::Molecule* m_mol;

  Core::Cube* m_cube;

  Vector3i*
    neighbors; // array of vectors representing the points adjacent to a point

  Vector3i** spheres; // An array of pointers to arrays of vectors representing
                      // all the points each sphere
  int* numbersOfVectors; // The number of vectors in each sphere
  bool* computed; // An array of bools that tells us if we've already computed
                  // the sphere for this element

  dataStruct* data;

  int numberOfSurfaceVoxels; // the number of voxels on the surface
  Vector3i* surfaceVoxels;   // array where we store all the voxels that are on
                             // our surface

  QFuture<void> m_future;
  QFutureWatcher<void> m_watcher;
  QVector<subCube> m_subCubes;
  QVector<atomStruct> m_atomStructs;
}; // End class EDTSurface

} // End namespace QtPlugins
} // End namespace Avogadro

#endif
