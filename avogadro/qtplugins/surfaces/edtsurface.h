/******************************************************************************
  This source file is part of the Avogadro project.

  This source code is released under the New BSD License, (the "License").
******************************************************************************/

#ifndef AVOGADRO_QTPLUGINS_EDTSURFACE_H
#define AVOGADRO_QTPLUGINS_EDTSURFACE_H

#include <avogadro/core/avogadrocore.h>
#include <avogadro/core/vector.h>

namespace Avogadro {
namespace Core {
class Cube;
class Molecule;
class Atom;
}

namespace QtPlugins {

  typedef struct dataStruct{
    Vector3 pTran;
    int boxLength;
    double probeRadius;
    double fixSf;
    double scaleFactor;
    Vector3 pMin, pMax;
    int pHeight, pWidth, pLength;
    int widXz[13];
    int* deptY[13];
    double cutRadius;
    int positIn, positOut, eliminate;
    int certificate;
    int totalSurfaceVox;
    int totalInnerVox;
    Vector3i *inArray, *outArray
  }dataStruct;//End struct dataStruct


class EDTSurface
{
public:
  //Constructor
  EDTSurface();

  //Destructor
  virtual ~EDTSurface();

  /*@brief Populates a cube with values generated by doing a Euclidean distance
  *transform on the molecule provided
  *@param mol A pointer to a the molecule from which the cube is to be generated
  *@param surfType an enum class representing the type of surface (VdW, SES, SAS)
  *@returns a pointer to the cube
  */

  Core::Cube *EDTCube(Core::Molecule *mol, Surfaces::Type surfType);

  //The copying over from array to Cube can and should be done in parallel

  /*@brief Populates a cube with values generated by doing a Euclidean distance
  *transform on the molecule provided
  *@param mol A pointer to a the molecule from which the cube is to be generated
  *@param surfType an enum class representing the type of surface (VdW, SES, SAS)
  *@param probeRadius a double representing the molecular radius of the solvent
  *@returns a pointer to the cube
  */

  Core::Cube *EDTCube(Core::Molecule *mol, Surfaces::Type surfType, double probeRadius);
  // Takes a molecule, a surface type and a probeRadius and

  /*@brief Sets a pointer to the desired molecule
  *@param mol a pointer to the molecule to be set
  */

  void setMolecule(Core::Molecule *mol);

  /*@brief Sets the probe radius to a desired value (default is 1.4 - water)
  *@param probeRadius The molecular radius of the solvent
  */

  void setProbeRadius(double probeRadius);

  /*@brief Copies cube from volumePixel array into Cube object
  */

private:

  void initPara(bool atomType, bool bType, int surfaceType);
  //This can be done concurrently, but maybe doesn't need to be
  void fillVoxels(bool atomType);
  //This can (and should be done concurrently)
  //Basically we need to bust it up into two functions
  //One that iterates through the atoms and calls fillAtom
  //And one that iterates through the cube and adjusts booleans accordingly
  void fillAtom(int indx);
  //This cannot be done concurrently, but there's nor eason for it to be
  void fillAtomWaals(int indx);
  //This cannot be done concurrently, but there's no reason for it to be
  void fillVoxelsWaals(bool atomType);
  //This can and should be done concurrently
  //This shouldn't need to be busted up into functions
  //Because we don't do the iterating through the cube part
  void fastOneShell(int* inNum, int* allocOut, Vector3i*** boundPoint,
                    int* outNum, int* elimi);
  //This cannot be done concurrently, we run into issues breaking up the cube
  void fastDistanceMap();
  //This can be done concurrently except for the call to fastOneShell
  void buildBoundary();
  //This cannot be done concurrently (boundary issues),
  //But that's fine because it only happens once
  void boundBox(bool atomType);
  //This can be done concurrently, but maybe doesn't need to be

  void boundingAtom(bool bType);
  //This can be done concurrently but maybe doesn't need to be

  //So mostly, we need a way to make fillVoxels and fillVoxelsWaals run concurrently

  Vector3i vectorFromArray(int* array);
    // Takes an array of integers and returns a vector3i

  int detail(unsigned char atomicNumber);
    // Takes an atomic number and returns an index for rasRad

  Molecule* m_mol;

  Cube* m_cube;

  volumePixel*** volumePixels;

  //These bool arrays should probably be converted into BitVectors
  bool*** isDone;
  bool*** isBound;
  bool*** inOut;
  int*** atomIds;

  dataStruct *data;
}; // End class EDTSurface

} // End namespace QtPlugins
} // End namespace Avogadro

#endif
